<!doctype html><html lang=zh><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><title>Halo的主页 - 深入 Kafka</title><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css><link rel=stylesheet href=../../css/halo.css><link rel=stylesheet href=../../css/github-markdown.css><link rel=stylesheet href=../../css/github-markdown-light.css><link rel=stylesheet href=../../css/markdown-rewrite.css><style>body{display:flex;flex-direction:column;align-items:center}a{color:#5e5e5e;text-decoration:none}</style></head><body><div id=top style=width:0;height:0></div><div class=top-button><a href=#top style=text-decoration:none>Top</a></div><div id=header><div style=width:100%;display:flex;align-items:center;height:100%><div class=disable-select style=display:flex;justify-content:flex-end;font-size:14pt;font-weight:700;color:#555><div style=margin-right:35px></div><div><a style=color:#555;text-decoration:none href=../../>&lt;Halo的主页/></a></div></div><div style=flex:1;display:flex;justify-content:flex-end;font-size:14pt;font-weight:700;color:#555><div style=margin-right:45px><a href=https://www.wecomz.com style=color:#555;text-decoration:none>WecomZ</a></div><div style=margin-right:45px><a href=../../article style=color:#555;text-decoration:none>文章</a></div><div style=margin-right:45px><a href=../../video style=color:#555;text-decoration:none>视频</a></div><div style=margin-right:45px><a href=../../about style=color:#555;text-decoration:none>关于</a></div><div style=margin-left:35px></div></div></div></div><div id=article-content><div class=content-header><div>《深入 Kafka》</div><div style=font-size:10pt;height:100%;display:flex;align-items:flex-end;padding-bottom:12pt;color:#5e5e5e;font-weight:lighter>在2022/07/02 13:43:10更新，大约共500字。</div></div><div class=content-desc><div style=font-size:50pt;font-weight:700;color:#eee;padding-right:15px>“</div><div style=line-height:50pt>了解一种分布式消息流服务，并掌握如何规划，然后进一步了解与开发相关的内容。</div><div style=font-size:50pt;font-weight:700;color:#eee;padding-left:15px>”</div></div><div class="content-area markdown-body"><h1 id=概念>概念</h1><p>Apache Kafka 是一个开源分布式事件流平台，被数千家公司用于高性能数据管道、流分析、数据集成和任务关键型应用程序。Apache Kafka 在制造业、银行、保险、电信等大数据分析与处理方面存在着巨大的用途，官网也说 &ldquo;More than 80% of all Fortune 100 companies trust, and use Kafka."。</p><p><img src=../../article/deep-in-kafka/kafka-arch.svg alt="Kafka 的架构"></p><p>官方网站：<a href=https://kafka.apache.org/>https://kafka.apache.org</a></p><p>笔者研发的 zTrader Framework 支持接入各种 MQ 中间件，其中 Kafka 也在支持的列表，用作交易日志、风控通知、实时消息、量化策略日志等。</p><p>学习 Kafka 的重要性可见一斑。</p><p>Kafka 的构建使用了如下几个概念：</p><ul><li>消费者：从 Kafka 中获取数据并进行处理。</li><li>消费者组：通过 ID 标识一个组，同组的消费者无法重复消费消息，不同组的可以。</li><li>生产者：向 Kafka 中投放数据。</li><li>集群：多个 Kafka 服务实例构成的逻辑概念。</li><li>节点（Broker）：一个 Kafka 服务实例。</li><li>主题（Topic）：一个逻辑概念，通常用于区分业务类型。</li><li>分区（Parition）：一个物理概念，一个主题中可以存在多个分区，分区落实到集群中的服务器存储上是目录。</li><li>消息：数据。</li></ul><h1 id=集群>集群</h1><p>下面介绍 Kafka 集群具备的特点。</p><h2 id=主从模式>主从模式</h2><p>Kafka 的高可用依赖于 Apache Zookeeper（官方网站：<a href=https://zookeeper.apache.org/>https://zookeeper.apache.org</a>），因此 Kafka 集群中需要 Zookeeper 集群。由于 Zookeeper 集群使用了 Zab 算法作为高可用方案，那么实际生产环境中建议部署5个 Zookeeper 节点。通常在 Zab 算法中3个节点认为是高可用的，当其中一个节点宕机以后，另外两个节点仍旧可以提供服务，但是如果这两个中任意一个损坏，那么整个集群将不可用，因此推荐部署5个节点。</p><blockquote><p><strong>什么是 Zookeeper?</strong></p><p>Apache ZooKeeper 致力于开发和维护开源服务器，实现高度可靠的分布式协调。</p><p>ZooKeeper 是一个集中式服务，用于维护配置信息、命名、提供分布式同步和提供组服务。分布式应用程序以某种形式使用所有这些类型的服务。每次实现它们时，都要做大量的工作来修复不可避免的错误和竞争情况。由于实现这些类型的服务的困难，应用程序最初通常会忽略它们，这使得它们在变化面前变得脆弱并且难以管理。即使做得正确，这些服务的不同实现也会导致应用程序部署时的管理复杂性。</p></blockquote><p>Kafka 集群中的节点都向 Zookeeper 注册，称为领导者（Leader）的叫做控制器节点（Controller），负责读写请求。如果成为追随者（Follow），那么只能从控制器节点同步数据。</p><h2 id=高吞吐量>高吞吐量</h2><p>Kafka 诞生于大数据蓬勃发展的时代，高吞吐量是必然的。一些精巧的设计包括：</p><ul><li>存储方面进行顺序写入（追加写）和分段存储。</li><li>查询方面使用了稀疏索引和二分查找。</li><li>网络方面借助了 Java NIO 的 Reactor 网络设计模式</li><li>无论是网络还是硬盘都借助了零拷贝机制。</li></ul><h3 id=顺序写入和分段存储>顺序写入和分段存储</h3><p>由于只是追加写入，那么磁盘数量和读写速度达到一定数量将会与内存持平。
现代 SSD 速度和价格逐渐变得低廉和高性能，再加上 RAID 技术，理论上硬盘读写不会成为瓶颈。
甚至一个硬盘通过 PCIe 总线直接连接 CPU。</p><p>Kafka 将数据叫做日志文件，<code>.index</code> 文件为索引文件，<code>.log</code> 文件是数据文件（默认1GB）。笔者认为 1GB 的大小很可能是 Kafka 官方经过各个使用场景的反馈和大量的生产环境测试得来的魔法数字，因此不建议更改。小文件可以避免查找时加载几百GB的文件带来的内存空间浪费。</p><h3 id=查询>查询</h3><p>Kafka 中提供两个概念用来表示位置：</p><ul><li>Offset：相对偏移位置。</li><li>Postiotion：磁盘物理位置。</li></ul><p>由于 Kafka 通常负载较多的数据，查询成为一个难题。官方源代码中使用稀疏索引构建 Offset 查询表。
然后通过比较 Offset 表条目的两端来快速确认到指定的 Offset 范围处于那几个行，然后加载目标行的全部 Offset，再去 Offset 和 Position 对应的表格中找到对应的物理磁盘位置。</p><p><img src=../../article/deep-in-kafka/kafka-maps.svg alt=查询></p><h3 id=零拷贝>零拷贝</h3><p>零拷贝在 Linux 上的技术为 <a href=https://man7.org/linux/man-pages/man2/sendfile.2.html>sendfile</a> 函数，Windows 上是 <a href=https://learn.microsoft.com/en-us/windows/win32/api/mswsock/nf-mswsock-transmitfile>TransmitFile</a> 函数。</p><p>如下图所示，Kafka 的数据读取在操作系统、硬盘和网卡之间是一层层拷贝的，利用零拷贝技术可以简化拷贝路径。如果当前的服务器主板具备DMA机制，那么将会实现更快的文件拷贝。</p><p><img src=../../article/deep-in-kafka/kafka-zero-copy.svg alt=零拷贝></p><h3 id=nio-的-reactor-模式>NIO 的 Reactor 模式</h3><p>Java 的 NIO 要比 BIO 复杂一些，我们从如何设计一个 Kafka 网络模型来了解 Kafka 网络。</p><p>通常情况下，Kafka 的客户端分为生产者和消费者，但是一个业务服务有可能既是生产者也是消费者，那么我们只需要客户端的概念。
客户端可以进行读写操作，我们在 Kafka 节点提供一个 <code>ServerSockerChannel</code> 监听默认端口 9092。<code>ServerSocketChannel</code> 向 <code>Selector</code> 注册 <code>OP_ACCEPT</code> 事件，当连接请求到来时，<code>Selector</code> 就会将请求进行派发，给到 <code>Acceptor</code>，<code>Acceptor</code> 创建一个 <code>SocketChannel</code> 对象来处理新的连接。</p><p><code>SocketChannel</code> 向 <code>Selector</code> 注册一个 <code>OP_READ</code> 事件。由一个新的处理线程监听注册的 <code>OP_READ</code> 事件，负责读取硬盘数据。这个新的处理线程向 <code>Selector</code> 注册 <code>OP_WRITE</code> 事件，当数据准备好后，由另一个新的处理线程监听 <code>OP_WRITE</code> 事件，另一个新的处理线程拿到数据响应给客户端。</p><p><img src=../../article/deep-in-kafka/network-java-nio.svg alt="Java 的 NIO"></p><p>但是这样存在问题，首先是每次都要创建新的线程，这消耗了资源，一个 Java 线程就是一个操作系统线程，JVM 的 Thread 类只是包装，另外一个问题是如果处理线程耗时太长将会影响后来的新请求。</p><ul><li>我们增加一个队列，解耦 <code>SocketChannel</code> 与整个系统，新创建的请求句柄直接写入到队列中，增加吞吐量，降低耦合。</li><li>再增加一个线程池，对处理线程进行复用。</li></ul><p><img src=../../article/deep-in-kafka/network-java-nio2.svg alt="Java 的 NIO 2"></p><p>其实这个方案还是存在问题，<code>ServerSocketChannel</code> 只是注册 <code>OP_ACCEPT</code> 事件然后转发，而 <code>Selector</code> 被大量的对象注册和取消注册各种事件，<code>Selector</code> 在该方案中压力是较大的，那么我们可以创建多个 <code>Selector</code> 。</p><p><img src=../../article/deep-in-kafka/network-java-nio3.svg alt="Java 的 NIO 3"></p><p>此时，我们的方案看起来没什么问题了。Kafka 的网络模型与我们的方案大体一致。</p><p><img src=../../article/deep-in-kafka/network-kafka.png alt="Kafka 网络架构"></p><p>在 Kafka 的源代码中，客户端（无论是生产者还是消费者）创建的 TCP 请求都会通过 <code>ServerSocketChannel</code> 监听的 9092（默认端口号）接收，然后交给 <code>Selector</code>，<code>ServerSocketChannel</code> 向 <code>Selector</code> 注册了 <code>OP_ACCEPT</code> 事件。Kafka 默认使用了三个 <code>Processor</code> 处理消息，每个 <code>Processor</code> 中都有一个队列，用来存放 <code>Selector</code> 创建的 <code>SocketChannel</code>，然后由 <code>KSelector</code> 消费，本质是个循环。<code>KSelector</code> 读取二进制数据，然后封装成 <code>Request</code> 对象放到 <code>RequestChannel</code> 中等待 <code>KafkaRequestHandlePool</code> 线程池中的 <code>KafkaHandleRequest</code> 线程（线程池默认大小为8。）消费。<code>KafkaHandleRequest</code> 线程联系内存和存储（例如文件系统），进行读写操作。然后，将响应的数据包装成 <code>Response</code> 对象放入 <code>ResponseQueue</code>，等待被循环消费发送给客户端。</p><h2 id=高可用>高可用</h2><p>在 Kafka 中，节点分为领导者和跟随者，领导者维护了 ISR（In Sync Replica）。消息写入到领导者的分区之后，Kafka 通过策略写入到了 ISR 中记录的跟随者，当大多数的跟随者写入消息成功后，那么 Kafka 的领导者就向生产者反馈消息投递成功。</p><h1 id=场景评估与容量规划>场景评估与容量规划</h1><p>大部分事物都遵循二八定律或者一九定律。</p><p>接下来我们将从一个每日10亿规模的请求量被发送到 Kafka 集群的案例开始。</p><h2 id=机器规模>机器规模</h2><p>我们知道，电商类应用的请求量依赖于终端用户，如果这个网站具备全球属性，那么你需要合理评估不同可用域的请求量分布情况。例如在 UTC+8:00 时区，人们通常早上7点就开始了新的一天，电商类应用的使用频段通常是午休或者晚上下班后，一些有各类活动的节日除外。</p><p>如果你开始新的架构，并没有日志可视化数据作为参考依据，那么经过运营专家们的评估后通常是 11:00AM ~ 14:00 AM 以及 17:00PM ~ 24:00 PM 是最活跃的时段。我们的集群需要花费上午的3小时加上下午的7小时处理 80% 的请求，也就是 8亿的请求（读写请求）。</p><p>那么我们计算以下高峰期的负载量：8亿 / 10 小时 = 22222 请求每秒。</p><p>假设每个请求是 30KB，通常情况下一个消息的大小只有几个字节，但是客户端程序通常会合并日志请求进行批量发送，那么我们假设最大合并大小为80条消息。</p><p>10亿 x 30KB = 28TB，每日需要存储 28TB 的数据。</p><p>假设我们为 Kafka 设置的副本数量为2，那么每个 Kafka 节点至少需要 56TB 的存储空间。我们在 Kafka 上的数据保留周期是3天，那么就是 168TB的数据量。</p><p>按照笔者的经验，通常2~3台物理机是可以负载的，考虑到负载的安全性，通常我们将资源数量升级为2~4倍。接下来我们来看看使用什么硬盘。
SSD（固态硬盘）具备较好的随机读写能力，像 MySQL 等数据库应用通常查询某个表格的某一行数据，无论经过存储引擎的怎样转换都是随机读写硬盘上的某个数据块。
Kafka 在我们前边提到是顺序写入的设计，因此我们更加偏向机械硬盘，企业级别的通常使用SAS硬盘的RAID阵列。</p><p>关于 RAID 级别的安全性与存储大小可以通过如下表格获得：</p><table><thead><tr><th>级别</th><th>最小硬盘数量</th><th>特性</th></tr></thead><tbody><tr><td>0</td><td>N >= 2</td><td>多个硬盘的直接组合，数据分为 N 份，并发的写入 N 个磁盘。读写性能是单硬盘的 N 倍，但是不提供数据安全性保证。</td></tr><tr><td>1</td><td>N >= 2</td><td>提供一个硬盘的容量，数据在 N 块硬盘之间拷贝，由于数据发生了镜像，那么安全性是最高的，但是一份数据的写入成功时间长短取决于最慢的那块硬盘。</td></tr><tr><td>2</td><td>N >= 2</td><td>RAID 0的改良版，以汉明码（Hamming Code）的方式将数据进行编码后分割为独立的位元，并将数据分别写入硬盘中。因为在数据中加入了错误修正码（ECC，Error Correction Code），所以数据整体的容量会比原始数据大一些。</td></tr><tr><td>3</td><td>N >= 3</td><td>多出了一个存储校验数据的硬盘。N-1块硬盘实现并发读写，使用校验数据盘进行数据恢复，但是校验数据盘处于频繁的读写状态。</td></tr><tr><td>4</td><td>N >= 3</td><td>与 RAID 3类似，但是条块单位为块或记录而不是位。</td></tr><tr><td>5</td><td>N >= 3</td><td>相较于 RAID 3，将校验数据分布在不同的硬盘上，允许最多同时坏一块磁盘。如果有两块磁盘同时损坏了，那数据就无法恢复了。</td></tr><tr><td>6</td><td>N >= 3</td><td>可以在有两块磁盘同时损坏的情况下，也能保障数据可恢复，引入了双重校验。虽然数据冗余性好，读取的效率比较高，但是写数据的性能差。</td></tr><tr><td>10</td><td>N >= 4</td><td>先用 50% 的硬盘组建 RAID 1，然后在两个 RAID 1 上构建 RAID 0。</td></tr><tr><td>7</td><td>-</td><td>Optimized Asynchrony for High I/O Rates as well as high Data Transfer Rates（最优化的异步高I/O速率和高数据传输率）。RAID 7等级是至今为止，理论上性能最高的RAID模式，它自身带有操作系统（实时事件驱动的操作系统）和管理工具，完全可以独立运行。</td></tr><tr><td>JBOD</td><td>-</td><td>严格上来说不是一种RAID，因为它只是简单将多个磁盘合并成一个大的逻辑盘，并没有任何的数据冗余。数据的存放机制就是从第一块磁盘开始依序向后存储数据。如果某个磁盘损毁，则该盘上的数据就会丢失。</td></tr></tbody></table><p>如果公司内部有专门的存储小组负责存储，可以通过系统直接申请创建光存储网络。</p><h2 id=集群规划>集群规划</h2><h2 id=zookeeper>Zookeeper</h2><h2 id=核心参数>核心参数</h2><h2 id=运维工具>运维工具</h2><h1 id=针对开发的相关问题>针对开发的相关问题</h1></div></div><footer id=footer><div class=footer-inner><div><div style=font-weight:700;margin-bottom:15px>发布地址</div><div><a href=https://founder.wecomz.com>Halo的主页自动加速体验</a></div><div><a href=https://bluemiaomiao.gitee.io>Halo的主页中国境内镜像</a></div><div><a href=https://bluemiaomiao.github.io>Halo的主页中国境外镜像</a></div></div><div><div style=font-weight:700;margin-bottom:15px>友情链接</div><div><a href=https://debuginn.cn>DebugInn</a></div><div><a href=https://blog.csdn.net/qq_43442524>普通Gopher</a></div></div><div><div style=font-weight:700;margin-bottom:15px>开源软件</div><div><a href=https://bluemiaomiao.github.io/libsshd/>OpenSSH Configuration Library</a></div><div><a href=https://bluemiaomiao.github.io/fastdfs-spring-boot-starter/>FastDFS SpringBoot Starter</a></div><div><a href=https://bluemiaomiao.github.io/librocm-smi-gobinding/>AMD ROCm SMI for Golang</a></div><div><a href=https://bluemiaomiao.github.io/libnvml-smi-gobinding>NVIDIA NVML SMI for Golang</a></div><div><a href=https://www.wecomz.com/software/zgraphics>zGraphics(Prometheus GPU Exporter)</a></div><div><a href=https://www.wecomz.com/software/ztrader>zTrader Framework</a></div></div><div><div style=font-weight:700;margin-bottom:15px>其他</div><div><a href=https://values.wecomz.com>WecomZ 价值观</a></div></div></div><div class=icp><div style=min-height:13px;min-width:13px;background-image:url(/image/beian.png);background-repeat:no-repeat;background-size:contain;margin-right:5px></div><div>鲁公网安备号</div></div></footer></body></html>