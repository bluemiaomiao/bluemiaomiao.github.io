<!doctype html><html lang=zh><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1"><title>Halo的主页 - Kubernetes Operator 开发</title><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/animate.css/4.1.1/animate.min.css><link rel=preconnect href=https://fonts.googleapis.com><link rel=preconnect href=https://fonts.gstatic.com crossorigin><link href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@500&display=swap" rel=stylesheet><link rel=stylesheet href=../../css/halo.css><link rel=stylesheet href=../../css/github-markdown.css><link rel=stylesheet href=../../css/github-markdown-light.css><link rel=stylesheet href=../../css/markdown-rewrite.css><link rel="shortcut icon" href=favicon.ico type=image/x-icon><link rel=apple-touch-icon sizes=180x180 href=../../apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=../../favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=../../favicon-16x16.png><link rel=manifest href=../../site.webmanifest><link rel=mask-icon href=../../safari-pinned-tab.svg color=#5bbad5><meta name=msapplication-TileColor content="#ffffff"><meta name=theme-color content="#ffffff"><style>body{display:flex;flex-direction:column;align-items:center}a{color:#5e5e5e;text-decoration:none}</style></head><body><div id=mob-warning>当前内容暂不适配移动端。<br>请使用桌面端查看。</div><div id=top style=width:0;height:0></div><div class=top-button><a href=#top style=text-decoration:none>Top</a></div><div id=toc>目<br>录</div><div id=header><div style=width:100%;display:flex;align-items:center;height:100%><div class=disable-select style=display:flex;justify-content:flex-end;font-size:14pt;font-weight:700;color:#555><div style=margin-right:35px></div><div><a style=color:#555;text-decoration:none href=../../>&lt;Halo的主页/></a></div></div><div style=flex:1;display:flex;justify-content:flex-end;font-size:14pt;font-weight:700;color:#555><div style=margin-right:45px><a href=https://www.wecomz.com style=color:#555;text-decoration:none>WecomZ</a></div><div style=margin-right:45px><a href=../../article style=color:#555;text-decoration:none>文章</a></div><div style=margin-right:45px><a href=../../video style=color:#555;text-decoration:none>视频</a></div><div style=margin-right:45px><a href=../../about style=color:#555;text-decoration:none>关于</a></div><div style=margin-left:35px></div></div></div></div><div id=article-content><div class=content-header><div>《Kubernetes Operator 开发》</div><div style=font-size:10pt;height:100%;display:flex;align-items:flex-end;padding-bottom:12pt;color:#5e5e5e;font-weight:lighter>在2023/06/23 00:30:13更新，大约共1200字。</div></div><div class=content-desc><div style=font-size:50pt;font-weight:700;color:#eee;padding-right:15px>“</div><div style=line-height:50pt;color:#9b9b9b>[迁移]开发 Operator 的指南</div><div style=font-size:50pt;font-weight:700;color:#eee;padding-left:15px>”</div></div><div class="content-area markdown-body"><p>Kubernetes 通过命令行（kubectl）或者 YAML 的方式将请求数据转换为 JSON，然后发送到 API Server，不同的资源会有不同的 Controller 来负责，Controller 维护了这些资源的期望状态。
例如 Pod、Service 等，这都是 Kubernetes 中预定义的对象，对于自定义的对象，我们就需要通过 Operator 来实现了。</p><p>Operator 概念由 CoreOS 的 CTO Brandon Philips 在2016年提出，SRE通过编写运维软件来运维应用，他们是工程师，也是开发者，知道怎么针对特定应用领域来开发运维软件，这些运维软件中包含特定应用领域的运维经验。
我们把这种新的软件类型叫作 Operator。</p><h1 id=前言>前言</h1><p>一个 Operator 是特定应用的控制器，通过拓展 Kubernetes API 来创建、配置和管理复杂有状态的应用实例，代替用户人工操作。它构建在 Kubernetes Resource 和 Controller 概念之上，同时包含领域或应用特定的知识，从而自动化地实现通用的运维任务。
Operator 模式是 Kubernetes 高度可拓展性的精髓所在，官方文档对 Operator 模式的介绍可以在中找到：<a href=https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/operator/>https://kubernetes.io/zh-cn/docs/concepts/extend-kubernetes/operator/</a>。Operator 的初衷在于人们都喜欢通过自动化来处理重复的任务，通过 Operator 来封装这些繁琐的流程。</p><p>Operator 可以做的事情如下：</p><ul><li>按需部署应用。</li><li>获取/还原应用状态的备份。</li><li>处理应用代码的升级以及相关改动。例如数据库 Schema 或额外的配置设置。</li><li>发布一个 Service，要求不支持 Kubernetes API 的应用也能发现它。</li><li>模拟整个或部分集群中的故障以测试其稳定性。</li><li>在没有内部成员选举程序的情况下，为分布式应用选择首领角色。</li></ul><p>一个典型的 Operator 如下：</p><ul><li>定义一个 Kubernetes 自定义资源，例如叫做 SampleDB。</li><li>一个包含 Operator Controller 部分的 Deployment（用于无状态的 CRD） 或者 StatefulSet（用于有状态的 CRD），用来确保 Pod 处于 Running 状态。</li><li>包含 Operator 代码的容器镜像。</li><li>Controller 代码，负责查询控制平面找出已经配置的 SampleDB 资源。</li><li>Operator 的核心是告诉 API Server，如何使现有 Kubernetes 集群状态与代码里配置的资源匹配，例如：<ul><li>如果添加新的 SampleDB，Operator 将设置 PersistentVolumeClaims 以提供持久化的数据库存储， 设置 StatefulSet 以运行 SampleDB，并设置 Job 来处理初始配置。</li><li>如果你删除它，Operator 将建立快照，然后确保 StatefulSet 和 Volume 已被删除。</li></ul></li><li>Operator 也可以管理常规数据库的备份。对于每个 SampleDB 资源，Operator 会确定何时创建（可以连接到数据库并进行备份的）Pod。这些 Pod 将依赖于 ConfigMap 和/或具有数据库连接详细信息和凭据的 Secret。</li><li>由于 Operator 旨在为其管理的资源提供强大的自动化功能，因此它还需要一些额外的支持性代码。 在这个示例中，代码将检查数据库是否正运行在旧版本上， 如果是，则创建 Job 对象为你升级数据库。</li></ul><p>部署 Operator 之后，可以通过 kubectl 命令来操作 SampleDB 这个对象，例如：</p><div class=highlight><div style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>watch kubectl get SampleDB -o wide
</span></span></code></pre></td></tr></table></div></div><p>那么，Operator 会负责应用所作的更改并保持现有服务处于良好的状态。</p><h1 id=开发>开发</h1><p>如果生态系统中没可以实现你目标的 Operator，你可以自己编写代码。你还可以使用任何支持 Kubernetes API 客户端的语言或运行时来实现 Operator（即 Controller）。</p><ul><li>如果你使用 Java，那么可以使用 <a href=https://github.com/operator-framework/java-operator-sdk>https://github.com/operator-framework/java-operator-sdk</a> 实现。</li><li>如果你使用 Python，那么可以使用 <a href=https://github.com/nolar/kopf>https://github.com/nolar/kopf</a> 实现。</li></ul><p>通常情况下，我们推荐使用 Go 语言实现 Operator，毕竟 Kubernetes 也是使用 Go 语言开发的，那么我们就会用到 <a href=https://book.kubebuilder.io/>https://book.kubebuilder.io/</a>。</p><h3 id=安装依赖>安装依赖</h3><p>目前 kubebuilder 仅支持 Linux 和 macOS，Windows 用户可以使用 WSL 来实现。下面我们来安装 kubebuilder:</p><div class=highlight><div style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>apt update <span style=color:#ff6ac1>&amp;&amp;</span> apt upgrade -y <span style=color:#ff6ac1>&amp;&amp;</span> apt install wget curl golang git make -y
</span></span><span style=display:flex><span>curl -L -o kubebuilder <span style=color:#5af78e>&#34;https://go.kubebuilder.io/dl/latest/</span><span style=color:#ff6ac1>$(</span>go env GOOS<span style=color:#ff6ac1>)</span><span style=color:#5af78e>/</span><span style=color:#ff6ac1>$(</span>go env GOARCH<span style=color:#ff6ac1>)</span><span style=color:#5af78e>&#34;</span>
</span></span><span style=display:flex><span>chmod +x kubebuilder <span style=color:#ff6ac1>&amp;&amp;</span> mv kubebuilder /usr/local/bin/
</span></span></code></pre></td></tr></table></div></div><p>接下来我们看一下版本信息：</p><div class=highlight><div style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubebuilder version
</span></span></code></pre></td></tr></table></div></div><p>看到输出了版本信息，说明安装成功了：</p><div class=highlight><div style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>Version: main.version<span style=color:#ff6ac1>{</span>KubeBuilderVersion:<span style=color:#5af78e>&#34;3.11.1&#34;</span>, KubernetesVendor:<span style=color:#5af78e>&#34;1.27.1&#34;</span>, GitCommit:<span style=color:#5af78e>&#34;1dc8ed95f7cc55fef3151f749d3d541bec3423c9&#34;</span>, BuildDate:<span style=color:#5af78e>&#34;2023-07-03T13:10:56Z&#34;</span>, GoOs:<span style=color:#5af78e>&#34;linux&#34;</span>, GoArch:<span style=color:#5af78e>&#34;amd64&#34;</span><span style=color:#ff6ac1>}</span>
</span></span></code></pre></td></tr></table></div></div><h3 id=创建项目>创建项目</h3><p>Kubebuilder 依赖于 Go 语言环境、Docker 和 Kubectl（确保可以访问到测试环境的 Kubernetes 集群）。</p><p>我们创建一个简单的 Operator，快速了解 Operator 的初始化、API 定义、打包和发布。我们要通过一个 Application 类型来定义一个自己的资源对象，然后在控制器中获取这个资源对象的详细配置，接着根据它的配置去创建相应数量的 Pod ，就像 Deployment 那样工作。</p><div class=highlight><div style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>mkdir helloworld-operator <span style=color:#ff6ac1>&amp;&amp;</span> <span style=color:#ff5c57>cd</span> helloworld-operator
</span></span><span style=display:flex><span>kubebuilder init --domain<span style=color:#ff6ac1>=</span>example.com --repo<span style=color:#ff6ac1>=</span>github.com/bluemiaomiao/helloworld-operator --owner <span style=color:#5af78e>&#34;Halo Hsu&#34;</span> --skip-go-version-check
</span></span></code></pre></td></tr></table></div></div><p>项目初始化完成以后会有很多目录和文件，其主要功能如下：</p><ul><li><code>PROJECT</code>：项目的元数据。</li><li><code>main.go</code>：主进程文件。</li><li><code>config</code>：分门别类的存放了许多 YAML 配置文件。</li><li><code>Dockerfile</code>：编译和构建二进制的全部逻辑都在这里。</li><li><code>Makefile</code>：通过 make 命令构建 Operator 应用。</li></ul><p>接下来我们创建一个自定义资源：</p><div class=highlight><div style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubebuilder create api --group myapp --version v1 --kind HelloWorld
</span></span></code></pre></td></tr></table></div></div><p>kubebuilder 帮助我们创建了 <code>config</code> 目录中的相关配置，<code>controllers</code> 目录中的一些文件，以及 <code>api</code> 目录。</p><ul><li><code>api</code> 目录包含了刚才添加的 API，需要注意 <code>helloworld_types.go</code> 文件。</li><li><code>config/crd</code> 存放的是用于部署 CRD 的 kustomize 文件。</li><li><code>config/rabc</code> 存放了用于查询和编辑权限的 ClusterRole 配置文件。</li><li><code>samples/myapp_v1_helloworld.yaml</code> 是一个 CR 的示例文件，通过这个文件就可以创建一个我们自定义的 HelloWorld 类型资源。</li><li><code>controllers</code> 包含了控制器代码的逻辑入口，需要重点关注 <code>Reconcile</code> 方法。</li></ul><h3 id=实现-crd>实现 CRD</h3><p>编辑 <code>api/v1/helloworld_types.go</code> 文件，添加一些属性：</p><div class=highlight><div style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ff5c57>type</span> HelloworldSpec <span style=color:#ff5c57>struct</span> {
</span></span><span style=display:flex><span>    Replicas <span style=color:#9aedfe>int32</span>                  <span style=color:#5af78e>`json:&#34;replicas,omitempty&#34;`</span>  <span style=color:#78787e>// Pod 的数量
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>    Template corev1.PodTemplateSpec <span style=color:#5af78e>`json:&#34;template,omitempty&#34;`</span>  <span style=color:#78787e>// Pod 的模板定义
</span></span></span><span style=display:flex><span><span style=color:#78787e></span>}
</span></span></code></pre></td></tr></table></div></div><h3 id=构建与部署>构建与部署</h3><p>修改好之后，就可以构建清单文件了：</p><div class=highlight><div style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>make manifests
</span></span></code></pre></td></tr></table></div></div><p>构建完成后会在 <code>config/crd/bases</code> 目录中新增 <code>myapp.example.com_helloworld.yaml</code> 文件，其中 Kind 是 <code>CustomResourceDefintion</code> 类型。
<code>spec.group</code> 是 <code>myapp.example.com</code>，<code>spec.kind</code> 是 <code>Hellworld</code> 类型。</p><p>接下来通过执行 <code>make install</code> 将 CRD 部署到 Kubernetes 集群中，然后就可以通过 kubectl 可以看到我们实现的 CRD：</p><div class=highlight><div style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>kubectl get crd
</span></span><span style=display:flex><span>kubectl get helloworld
</span></span></code></pre></td></tr></table></div></div><p>此时 API Server 已经识别这种资源了。我们可以通过编写 YAML 来创建 CRD，但是并不会有任何 Pod 被创建出来，因为还没有实现 <code>Reconcile()</code> 方法。</p><p>通过 <code>make run</code> 实现测试运行，此时会打印大量的日志到标准输出。</p><h3 id=在集群上运行>在集群上运行</h3><div class=highlight><div style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>make docker-build docker-push <span style=color:#ff5c57>IMG</span><span style=color:#ff6ac1>=</span>&lt;some-registry&gt;/&lt;project-name&gt;:tag
</span></span></code></pre></td></tr></table></div></div><p>将控制器部署到具有指定镜像的集群:</p><div class=highlight><div style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>make deploy <span style=color:#ff5c57>IMG</span><span style=color:#ff6ac1>=</span>&lt;some-registry&gt;/&lt;project-name&gt;:tag
</span></span></code></pre></td></tr></table></div></div><p>如果你要取消 CRD 并卸载：</p><div class=highlight><div style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>make undeploy
</span></span><span style=display:flex><span>make uninstall
</span></span></code></pre></td></tr></table></div></div><p>到这里，我们知道了开发一个 Operator 的具体步骤，接下来的章节将会与 Operator 有关。</p><h1 id=kubernetes-api>Kubernetes API</h1><p>kube-apiserver 通过 HTTPS 来通信，而且是 TLS 认证，在开发 Operator 的时候，重点关注的是 Kubernetes API 本身，因此可以通过 <code>kubectl proxy --port=9090</code> 来进行代理。
此时，通过 curl 或者 Postman 就可以与 Kubernetes 通信了，Kubernetes API 是标准的 Restful API。</p><p>与 API 关系比较大的是 GVK 这个概念，也就是：Group、Version、Kind。
我们在描述Kubernetes API时经常会用到这样一个四元组：Groups、Versions、Kinds 和 Resources。</p><p>一个 Group 表示的是一些相关功能的集合，比如 apps 这个 Group 里面就包含 deployments、replicasets、daemonsets、statefulsets 等资源，这些资源都是应用工作负载相关的，也就放在了同一个 Group 下。
一个 Group 可以有一个或多个 Version，不难理解这里的用意，毕竟随着时间的推移，一个 Group 中的 API 难免有所变化。</p><p>每一个 Group 中会有不同类型的 API，这就需要使用 Kind 来描述了，每个 Kind 在不同的版本中一般会有所差异，但是每个版本的 Kind 要能够存储其他版本 Kind 的资源类型，无论是通过存储在字段里实现还是通过存储在注解中实现。
这也就意味着使用老版本的 API 存储新版本类型数据不会引起数据丢失或污染。</p><p>至于 Resources，指的是一个 Kind 的具体使用，比如Pod类型对应的资源是 pods。
Kind 和 Resources 往往是一一对应的，尤其是在 CRD 的实现上。常见的特例就是为了支持 HorizontalPodAutoscaler(HPA) 和不同类型交互，Scale 类型对应的资源有 deployments/scale 和 replicasets/scale 两种。</p><h1 id=client-go-库>client-go 库</h1><p>client-go 项目就是用于和 Kubernetes API Server 通信的 Go 语言开发工具包。虽然使用 kubebuilder 已经屏蔽了不少 client-go 的细节，但是要深入 Operator 开发机制，还是需要对 client-go 有一定的了解。</p><p>client-go 的存储库地址是：<a href=https://github.com/kubernetes/client-go>https://github.com/kubernetes/client-go</a>。这个库的代码是以每天一次的频率从 <code>kubernetes/kubernetes</code> 存储库库中自动同步过来的。
如果你想直接使用该库，可以在项目中直接添加依赖：</p><div class=highlight><div style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-shell data-lang=shell><span style=display:flex><span>go get k8s.io/client-go@laest
</span></span></code></pre></td></tr></table></div></div><p>对于 client-go 的认证，分为集群内和集群外，集群内部 Kubernetes 会自动挂载 ServiceAccunt 中的 JWT 和 ca.crt，集群外部直接使用 kubeconfig 文件即可。</p><p>编写自定义控制器依赖多个 client-go 组件，下面我们介绍 client-go 中的几个机制。</p><p><img src=../../article/kubernetes-operator/operator-arch.svg alt></p><ul><li>Reflector 从 API Server 监听 (Watch) 特定类型的资源，拿到变更通知后，将其 Push 到 DeltaFIFO 队列中。</li><li>Informer 从 DeltaFIFO 中 Pop 出对象，然后通过 Indexer 将对象和索引放到本地缓存中，再触发相应的事件处理函数(Resource Event Handlers)。</li><li>Indexer 主要提供一个对象根据一定条件检索的能力，典型的实现是通过 namespace/name 来构造key，通过 Thread Safe Store 来存储对象。</li><li>WorkQueue 一般使用的是延时队列实现，在 Resource Event Handlers 中会完成将对象的 key 放入 WorkQueue 的过程，然后在自己的逻辑代码里从 WorkQueue 中消费这些 key。</li><li>ClientSet提供的是资源的读写能力，与 API Server 交互。</li><li>我们一般在 Resource Event Handlers 中添加一些简单的过滤功能，判断哪些对象需要加到 WorkQueue 中进一步处理，对于需要加到 WorkQueue 中的对象，就提取其 key，然后 Push 到队列中。</li><li>Worker 指的是我们自己的业务代码处理过程，在这里可以直接收到 WorkQueue 中的任务，可以通过 Indexer 从本地缓存检索对象，通过 ClientSet 实现对象的增、删、改、查逻辑。</li></ul><h2 id=workqueue>WorkQueue</h2><p>WorkQueue 称为工作队列，Kubernetes 的 WorkQueue 队列与普通 FIFO（先进先出，First-In, First-Out）队列相比，实现略显复杂，它的主要功能在于标记和去重，并支持如下特性。</p><ul><li>有序：按照添加顺序处理元素（item）。</li><li>去重：相同元素在同一时间不会被重复处理，例如一个元素在处理之前被添加了多次，它只会被处理一次。</li><li>并发性：多生产者和多消费者。</li><li>标记机制：支持标记功能，标记一个元素是否被处理，也允许元素在处理时重新排队。</li><li>通知机制：ShutDown 方法通过信号量通知队列不再接收新的元素，并通知 metric goroutine 退出。</li><li>延迟：支持延迟队列，延迟一段时间后再将元素存入队列。</li><li>限速：支持限速队列，元素存入队列时进行速率限制。限制一个元素被重新排队（Reenqueued）的次数。</li><li>指标：支持监控指标，可用于 Prometheus 监控。</li></ul><p>WorkQueue 主要有3个队列：普通队列、延时队列和限速队列。后一个队列以前一个队列的实现为基础，层层添加新功能。</p><h3 id=普通队列>普通队列</h3><p>FIFO 队列支持最基本的队列方法，WorkQueue 中的限速及延迟队列都基于 Interface 接口实现：</p><div class=highlight><div style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">8
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ff5c57>type</span> Interface <span style=color:#ff5c57>interface</span> {
</span></span><span style=display:flex><span>    <span style=color:#57c7ff>Add</span>(item <span style=color:#ff5c57>interface</span>{})
</span></span><span style=display:flex><span>    <span style=color:#57c7ff>Len</span>() <span style=color:#9aedfe>int</span>
</span></span><span style=display:flex><span>    <span style=color:#57c7ff>Get</span>() (item <span style=color:#ff5c57>interface</span>{}, shutdown <span style=color:#9aedfe>bool</span>)
</span></span><span style=display:flex><span>    <span style=color:#57c7ff>Done</span>(item <span style=color:#ff5c57>interface</span>{})
</span></span><span style=display:flex><span>    <span style=color:#57c7ff>ShutDown</span>()
</span></span><span style=display:flex><span>    <span style=color:#57c7ff>ShuttingDown</span>() <span style=color:#9aedfe>bool</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>FIFO 队列的类型定义如下：</p><div class=highlight><div style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ff5c57>type</span> Type <span style=color:#ff5c57>struct</span> {
</span></span><span style=display:flex><span>    queue []t
</span></span><span style=display:flex><span>    dirty set
</span></span><span style=display:flex><span>    processing set
</span></span><span style=display:flex><span>    cond <span style=color:#ff6ac1>*</span>sync.Cond
</span></span><span style=display:flex><span>    shuttingDown <span style=color:#9aedfe>bool</span>
</span></span><span style=display:flex><span>    metrics queueMetrics
</span></span><span style=display:flex><span>    unfinishedWorkUpdatePeriod time.Duration
</span></span><span style=display:flex><span>    clock clock.Clock
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p><code>queue</code> 字段用来存储真正的元素，<code>t</code> 类型的 Slice 结构，保证了元素的有序。
<code>dirty</code> 字段保证了队列去重功能，还能保证并发情况下只处理一次。
<code>processing</code> 字段用于标记机制，标记一个元素是否正在被处理。</p><p>在并发场景下，假设 Goroutine A 通过 Get 方法获取 1 元素，1 元素被添加到 <code>processing</code> 字段中，同一时间，Goroutine B 通过 Add 方法插入另一个 1 元素，此时在 <code>processing</code> 字段中已经存在相同的元素，
所以后面的 1 元素并不会被直接添加到 <code>queue</code> 字段中，当前 FIFO 队列中的 <code>dirty</code> 字段中存有 1、2、3 元素，<code>processing</code> 字段存有 1 元素。在 Goroutine A 通过 Done 方法标记处理完成后，如果 <code>dirty</code> 字段中存有 1 元素，
则将 1 元素追加到 <code>queue</code> 字段中的尾部。需要注意的是，<code>dirty</code> 和 <code>processing</code> 字段都是用 HashMap 数据结构实现的，所以不需要考虑无序，只保证去重即可。</p><h3 id=延迟队列>延迟队列</h3><p>延迟队列，基于 FIFO 队列接口封装，在原有功能上增加了 <code>AddAfter</code> 方法，其原理是延迟一段时间后再将元素插入 FIFO 队列。</p><div class=highlight><div style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ff5c57>type</span> DelayingInterface <span style=color:#ff5c57>interface</span> {
</span></span><span style=display:flex><span>    Interface
</span></span><span style=display:flex><span>    <span style=color:#57c7ff>AddAfter</span>(item <span style=color:#ff5c57>interface</span>{}, duration time.Duration)
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff5c57>type</span> delayingType <span style=color:#ff5c57>struct</span> {
</span></span><span style=display:flex><span>    Interface
</span></span><span style=display:flex><span>    clock clock.Clock
</span></span><span style=display:flex><span>    stopCh <span style=color:#ff5c57>chan</span> <span style=color:#ff5c57>struct</span>{}
</span></span><span style=display:flex><span>    heartbeat clock.Ticker
</span></span><span style=display:flex><span>    waitingForAddCh <span style=color:#ff5c57>chan</span> <span style=color:#ff6ac1>*</span>waitFor
</span></span><span style=display:flex><span>    metrics           retryMetrics
</span></span><span style=display:flex><span>    deprecatedMetrics retryMetrics
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p><code>delayingType</code> 结构中最主要的字段是 <code>waitingForAddCh</code>，其默认初始大小为 1000，通过 <code>AddAfter</code> 方法插入元素时，是非阻塞状态的，只有当插入的元素大于或等于 1000 时，延迟队列才会处于阻塞状态。
<code>waitingForAddCh</code> 字段中的数据通过 Goroutine 运行的 <code>waitingLoop</code> 函数持久运行。</p><p>将元素 1 放入 <code>waitingForAddCh</code> 字段中，通过 <code>waitingLoop</code> 函数消费元素数据。当元素的延迟时间不大于当前时间时，说明还需要延迟将元素插入 FIFO 队列的时间，此时将该元素放入优先队列（<code>waitForPriorityQueue</code>）中。
当元素的延迟时间大于当前时间时，则将该元素插入 FIFO 队列中。另外，还会遍历优先队列（<code>waitForPriorityQueue</code>）中的元素，按照上述逻辑验证时间。</p><h3 id=限速队列>限速队列</h3><p>限速队列，基于延迟队列和 FIFO 队列接口封装，限速队列接口（<code>RateLimitingInterface</code>）在原有功能上增加了 <code>AddRateLimited</code>、<code>Forget</code>、<code>NumRequeues</code> 方法。
限速队列的重点不在于 <code>RateLimitingInterface</code> 接口，而在于它提供的 4 种限速算法接口（<code>RateLimiter</code>）。其原理是，限速队列利用延迟队列的特性，延迟某个元素的插入时间，达到限速目的。</p><div class=highlight><div style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">5
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ff5c57>type</span> RateLimiter <span style=color:#ff5c57>interface</span> {
</span></span><span style=display:flex><span>    <span style=color:#57c7ff>When</span>(item <span style=color:#ff5c57>interface</span>{}) time.Duration
</span></span><span style=display:flex><span>    <span style=color:#57c7ff>Forget</span>(item <span style=color:#ff5c57>interface</span>{})
</span></span><span style=display:flex><span>    <span style=color:#57c7ff>NumRequeues</span>(item <span style=color:#ff5c57>interface</span>{}) <span style=color:#9aedfe>int</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>4中限速算法分别是：令牌桶算法（<code>BucketRateLimiter</code>）、排队指数算法（<code>ItemExponentialFailureRateLimiter</code>）、
计数器算法（<code>ItemFastSlowRateLimiter</code>）和混合模式（<code>MaxOfRateLimiter</code>），将多种限速算法混合使用混合模式（<code>MaxOfRateLimiter</code>），将多种限速算法混合使用。</p><p>令牌桶算法是通过 Go 语言的第三方库 <code>golang.org/x/time/rate</code> 实现的。
令牌桶算法内部实现了一个存放 Token（令牌）的“桶”，初始时“桶”是空的，Token 会以固定速率往“桶”里填充，直到将其填满为止，多余的 Token 会被丢弃。
每个元素都会从令牌桶得到一个 Token，只有得到 Token 的元素才允许通过，而没有得到 Token 的元素处于等待状态。
<strong>令牌桶算法通过控制发放 Token 来达到限速目的。</strong> WorkQueue 在默认的情况下会实例化令牌桶算法。</p><p>排队指数算法将相同元素的排队数作为指数，排队数增大，速率限制呈指数级增长，
但其最大值不会超过 <code>maxDelay</code>。元素的排队数统计是有限速周期的，一个限速周期是指从执行 <code>AddRateLimited</code> 方法到执行完 <code>Forget</code> 方法之间的时间。如果该元素被 <code>Forget</code> 方法处理完，则清空排队数。</p><p>计数器算法是限速算法中最简单的一种，其原理是：限制一段时间内允许通过的元素数量，例如在 1 分钟内只允许通过 100 个元素，
每插入一个元素，计数器自增 1，当计数器数到 100 的阈值且还在限速周期内时，则不允许元素再通过。但 WorkQueue 在此基础上扩展了 <code>fast</code> 和 <code>slow</code> 速率。</p><h2 id=deltafifo>DeltaFIFO</h2><p>DetlaFIFO 同时实现了 <code>Queue</code> 和 <code>Store</code> 接口，使用 <code>items</code> 保存了对象状态的变更，并且它们是内嵌关系：</p><div class=highlight><div style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ff5c57>type</span> Queue <span style=color:#ff5c57>interface</span> {
</span></span><span style=display:flex><span>    Store
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><div class=highlight><div style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ff5c57>type</span> DeltaFIFO <span style=color:#ff5c57>struct</span> {
</span></span><span style=display:flex><span>    items <span style=color:#ff5c57>map</span>[<span style=color:#9aedfe>string</span>]<span style=color:#9aedfe>string</span> Deltas
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p><code>DeltaFIFO</code> 存储元素使用了 <code>Deltas</code> 类型，<code>Deltas</code> 类型是一个类型别名：</p><div class=highlight><div style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ff5c57>type</span> Deltas []Delta
</span></span></code></pre></td></tr></table></div></div><p><code>Delta</code> 类型由 <code>Type</code> 和 <code>Object</code> 构成。<code>Type</code> 是 <code>DeltaType</code> 类型的，本质上是模拟了枚举。而 <code>Object</code> 是 <code>any</code> 类型的。</p><h2 id=listerwatcher>ListerWatcher</h2><p>ListerWatcher 是 Lister 和 Watcher 的结合体，前者负责列举全量对象，后者负责监视对象的增量变化。
Kubernetes 将对象全部存储到 ETCD 中，并且只能通过 API Server 访问，如果很多客户端频繁的列举对象，会给 API Server 造成重负，因此，ListerWatcher 是带有本地缓存功能的。
增量监视 ETCD 中的对象变化，并将这些差异更新到本地缓存。这里的本地缓存就是 Indexer，还带有索引加速功能。</p><p>Lister 是一个接口：</p><div class=highlight><div style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ff5c57>type</span> Lister <span style=color:#ff5c57>interface</span> {
</span></span><span style=display:flex><span>    <span style=color:#57c7ff>List</span>(options metav1.ListOptions) (runtime.Object, <span style=color:#9aedfe>error</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>同样 Watcher 也是个接口：</p><div class=highlight><div style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">3
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ff5c57>type</span> Watcher <span style=color:#ff5c57>interface</span> {
</span></span><span style=display:flex><span>    <span style=color:#57c7ff>Watch</span>(options metav1.ListOptions) (watch.Interface, <span style=color:#9aedfe>error</span>)
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>因此 ListerWatcher 接口就是将这两个接口进行了合并操作。ListerWatcher 主要用于创建各种 API 对象的 SharedIndexInformer，实现就是 Clientset 提供的 List 和 Watch 函数。</p><h2 id=informer>Informer</h2><p>Informer（也叫做 SharedInformer）是 Kubernetes 控制器（Controller）中的模块，
是控制器调谐循环（Reconcile Loop）与 Kubernetes API Server 事件（也就是 ETCD 中 Kubernetes API 数据变化）挂接的桥梁，
我们通过 API Server 增删改某个 Kubernetes API 对象，该资源对应的控制器中的 Informer 会立即感知到这个事件并作出调谐。</p><div class=highlight><div style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><table style=border-spacing:0;padding:0;margin:0;border:0><tr><td style=vertical-align:top;padding:0;margin:0;border:0><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 1
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 2
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 3
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 4
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 5
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 6
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 7
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 8
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f"> 9
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">10
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">11
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">12
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">13
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">14
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">15
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">16
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">17
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">18
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">19
</span><span style="white-space:pre;-webkit-user-select:none;user-select:none;margin-right:.4em;padding:0 .4em;color:#7f7f7f">20
</span></code></pre></td><td style=vertical-align:top;padding:0;margin:0;border:0;width:100%><pre tabindex=0 style=color:#e2e4e5;background-color:#282a36;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=display:flex><span><span style=color:#ff5c57>type</span> SharedIndexInformer <span style=color:#ff5c57>interface</span> {
</span></span><span style=display:flex><span>    SharedInformer
</span></span><span style=display:flex><span>    <span style=color:#57c7ff>AddIndexers</span>(indexers Indexers) <span style=color:#9aedfe>error</span>
</span></span><span style=display:flex><span>    <span style=color:#57c7ff>GetIndexer</span>() Indexer
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#ff5c57>type</span> sharedIndexInformer <span style=color:#ff5c57>struct</span> {
</span></span><span style=display:flex><span>    indexer    Indexer
</span></span><span style=display:flex><span>    controller Controller
</span></span><span style=display:flex><span>    processor             <span style=color:#ff6ac1>*</span>sharedProcessor
</span></span><span style=display:flex><span>    cacheMutationDetector MutationDetector
</span></span><span style=display:flex><span>    listerWatcher ListerWatcher
</span></span><span style=display:flex><span>    objectType runtime.Object
</span></span><span style=display:flex><span>    resyncCheckPeriod time.Duration
</span></span><span style=display:flex><span>    defaultEventHandlerResyncPeriod time.Duration
</span></span><span style=display:flex><span>    clock clock.Clock
</span></span><span style=display:flex><span>    started, stopped <span style=color:#9aedfe>bool</span>
</span></span><span style=display:flex><span>    startedLock      sync.Mutex
</span></span><span style=display:flex><span>    blockDeltas sync.Mutex
</span></span><span style=display:flex><span>}
</span></span></code></pre></td></tr></table></div></div><p>可以看到 Informer 由三部分构成：</p><ul><li>Reflector：Informer 通过 Reflector 与 Kubernetes API Server 建立连接并 ListAndWatch Kubernetes 资源对象的变化，并将此“增量” Push 到 DeltaFIFO Queue 中。</li><li>DeltaFIFO Queue：Informer 从该队列中 pop 增量，或创建或更新或删除本地缓存（Local Store）。</li><li>Indexer：将增量中的 Kubernetes 资源对象保存到本地缓存中，并为其创建索引，这份缓存与 etcd 中的数据是完全一致的。</li></ul><p>Watch 方法的实现是一个典型的 HTTP 请求，但是 Kubernetes apiserver 首次应答的 HTTP Header 中会携带上 <code>Transfer-Encoding: chunked</code>，表示分块传输，客户端会保持这条 TCP 连接并等待下一个数据块。
如此 API Server 会主动将监听的 Kubernetes 资源对象的变化不断地推送给客户端。</p></div></div><footer id=footer><div class=footer-inner><div><div style=font-weight:700;margin-bottom:15px>发布地址</div><div><a href=https://halo.wecomz.com>Halo的主页</a></div><div><a href=https://bluemiaomiao.gitee.io>中国境内镜像</a></div><div><a href=https://bluemiaomiao.github.io>中国境外镜像</a></div></div><div><div style=font-weight:700;margin-bottom:15px>友情链接</div><div><a href=https://debuginn.cn>DebugInn</a></div><div><a href=https://blog.csdn.net/qq_43442524>普通Gopher</a></div></div><div><div style=font-weight:700;margin-bottom:15px>开源软件</div><div><a href=https://bluemiaomiao.github.io/libsshd/>OpenSSH Configuration Library</a></div><div><a href=https://bluemiaomiao.github.io/fastdfs-spring-boot-starter/>FastDFS SpringBoot Starter</a></div><div><a href=https://bluemiaomiao.github.io/librocm-smi-gobinding/>AMD ROCm SMI for Golang</a></div><div><a href=https://bluemiaomiao.github.io/libnvml-smi-gobinding>NVIDIA NVML SMI for Golang</a></div><div><a href=https://www.wecomz.com/software/zgraphics>zGraphics(Prometheus GPU Exporter)</a></div><div><a href=https://www.wecomz.com/software/ztrader>zTrader Framework</a></div></div><div><div style=font-weight:700;margin-bottom:15px>其他</div><div><a href=https://values.wecomz.com>WecomZ 价值观</a></div></div></div><div class=icp><div style=min-height:13px;min-width:13px;background-image:url(/image/beian.png);background-repeat:no-repeat;background-size:contain;margin-right:5px></div><div><a href=https://beian.miit.gov.cn target=_blank>鲁ICP备2023019133号</a></div></div></footer></body><script src=../../js/halo.js type=text/javascript></script></html>